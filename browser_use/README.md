# Codebase Structure

> The code structure inspired by https://github.com/Netflix/dispatch.

Very good structure on how to make a scalable codebase is also in [this repo](https://github.com/zhanymkanov/fastapi-best-practices).

Just a brief document about how we should structure our backend codebase.

## Code Structure

```markdown
src/
/<service name>/
models.py
services.py
prompts.py
views.py
utils.py
routers.py

    	/_<subservice name>/
```

### Service.py

Always a single file, except if it becomes too long - more than ~500 lines, split it into \_subservices

### Views.py

Always split the views into two parts

```python
# All
...

# Requests
...

# Responses
...
```

If too long → split into multiple files

### Prompts.py

Single file; if too long → split into multiple files (one prompt per file or so)

### Routers.py

Never split into more than one file

# Repository Structure

The repository is organized into several directories, each serving a specific purpose:

- `browser_use/agent`: Contains the agent-related code, including prompts and services.
- `browser_use/browser`: Contains the browser-related code, including services and views.
- `browser_use/controller`: Contains the controller-related code, including registry and views.
- `ui`: Contains the frontend implementation files.
- `tests`: Contains the testing files.

# Code Organization

The code is organized into different modules to ensure modularity and reusability:

- `browser_use/agent/service.py`: Contains the main agent logic and interactions with the LLM.
- `browser_use/agent/views.py`: Contains the data models and views for the agent.
- `browser_use/browser/service.py`: Contains the browser automation logic using Selenium.
- `browser_use/browser/views.py`: Contains the data models and views for the browser state.
- `browser_use/controller/registry/service.py`: Contains the registry logic for registering and managing actions.
- `browser_use/controller/registry/views.py`: Contains the data models and views for the action registry.
- `browser_use/controller/service.py`: Contains the main controller logic and action execution.
- `browser_use/controller/views.py`: Contains the data models and views for the controller actions.
- `ui/App.js`: Contains the main React component for the frontend.
- `ui/BrowserView.js`: Contains the React component for displaying the browser view.
- `ui/AgentReasoning.js`: Contains the React component for displaying the agent's reasoning.
- `ui/MermaidDiagram.js`: Contains the React component for displaying the mermaid diagram.
- `ui/index.js`: Contains the entry point for the React application.
- `ui/webpack.config.js`: Contains the webpack configuration for the frontend.
- `ui/package.json`: Contains the project setup and dependencies for the frontend.

# Frontend Implementation

The frontend is implemented using React and is organized into several components:

- `App.js`: The main component that manages the state and interactions.
- `BrowserView.js`: Displays the browser view in an iframe.
- `AgentReasoning.js`: Displays the agent's reasoning steps.
- `MermaidDiagram.js`: Displays the mermaid diagram generated by the agent.
- `index.js`: The entry point for the React application.
- `webpack.config.js`: The webpack configuration for bundling the frontend.
- `package.json`: The project setup and dependencies for the frontend.

# Backend Architecture

The backend is implemented using FastAPI and is organized into several modules:

- `browser_use/api.py`: Contains the API endpoints for running tasks and interacting with the agent.
- `browser_use/agent/service.py`: Contains the main agent logic and interactions with the LLM.
- `browser_use/agent/views.py`: Contains the data models and views for the agent.
- `browser_use/browser/service.py`: Contains the browser automation logic using Selenium.
- `browser_use/browser/views.py`: Contains the data models and views for the browser state.
- `browser_use/controller/registry/service.py`: Contains the registry logic for registering and managing actions.
- `browser_use/controller/registry/views.py`: Contains the data models and views for the action registry.
- `browser_use/controller/service.py`: Contains the main controller logic and action execution.
- `browser_use/controller/views.py`: Contains the data models and views for the controller actions.

# API Integrations

The project integrates with several APIs to provide its functionality:

- OpenAI API: Used for interacting with the GPT-4 model.
- Anthropic API: Used for interacting with the Claude model.
- FastAPI: Used for creating the API endpoints.

# Testing Implementation

The project includes several tests to ensure the functionality of the code:

- Unit tests for utilities and helpers.
- Integration tests for API endpoints.
- Component tests for the frontend.
- End-to-end (E2E) tests for critical user flows.
- Performance tests.
- Security tests.

To run the tests, use the following command:

```bash
pytest
```

# Running the Project

To run the project, follow these steps:

1. Clone the repository:

```bash
git clone https://github.com/your-username/browser-use.git
cd browser-use
```

2. Create a virtual environment and install dependencies:

```bash
python -m venv venv
source venv/bin/activate  # On Windows use `venv\Scripts\activate`
pip install -r requirements.txt
```

3. Add your API keys to the `.env` file:

```bash
cp .env.example .env
```

or copy the following to your `.env` file:

```bash
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
```

4. Run the FastAPI server:

```bash
uvicorn browser_use.api:app --reload
```

5. Open your browser and navigate to `http://localhost:8000` to access the frontend.

# Contributing

Contributions are welcome! Feel free to open issues for bugs or feature requests.

## Local Setup

1. Create a virtual environment and install dependencies:

```bash
# To install all dependencies including dev
pip install . ."[dev]"
```

2. Add your API keys to the `.env` file:

```bash
cp .env.example .env
```

or copy the following to your `.env` file:

```bash
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
```

You can use any LLM model supported by LangChain by adding the appropriate environment variables. See [langchain models](https://python.langchain.com/docs/integrations/chat/) for available options.

## Building the package

```bash
hatch build
```

Feel free to join the [Discord](https://link.browser-use.com/discord) for discussions and support.
